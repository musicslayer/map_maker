<!DOCTYPE html>
<html lang="en-US">	
	<head>
		<title>Canvas</title>
	</head>

	<body>
		<!-- <h1>Canvas</h1> -->
		
		<canvas id="canvas" style="border:10px solid"></canvas>
		
		<script src="/socket.io/socket.io.js"></script>
		
		<script>
			const FPS_RATE = 60; // times per second
			//const FPS_RATE = 1; // times per second
			
			const NUM_TILES_X = 16;
			const NUM_TILES_Y = 12;
			const SIDE_PANEL_TILES = 10;
			const IMAGE_SCALE_FACTOR = 64;
			
			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			
			const canvas_width = (NUM_TILES_X + SIDE_PANEL_TILES) * IMAGE_SCALE_FACTOR;
			const canvas_height = NUM_TILES_Y * IMAGE_SCALE_FACTOR;
			
			let socket;
			let interval;
		
			let isUpdating = false;
			
			let isKeyPressed = {};
			
			window.addEventListener('load', () => {
				if(socket) {
					socket.disconnect(true);
				}
				
				socket = io({query: {key: "xyz"}});
				
				socket.on("connect", (err) => {
					startUpdateInterval();
				});
				
				socket.on("disconnect", (err) => {
					clearInterval(interval);
					socket.disconnect(true);
				});
			});
			
			/*
			window.addEventListener("gamepadconnected", (e) => {
				/onsole.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
					e.gamepad.index,
					e.gamepad.id,
					e.gamepad.buttons.length,
					e.gamepad.axes.length
				);
			});
			*/
			
			canvas.width = canvas_width;
			canvas.height = canvas_height;
			
			
			canvas.addEventListener("contextmenu", function (e){
				e.preventDefault();
			}, false);
			
			
			const manClickDeltaSpace = 10;
			const manClickDeltaTime = 100;
			let deltaSpace;
			let startX;
			let startY;
			let startT;
			
			let downButton;

			canvas.addEventListener('mousedown', function (e) {
				e.preventDefault()
				
				if(downButton === undefined) {
					downButton = e.button;
					const rect = canvas.getBoundingClientRect();
					startX = e.clientX - rect.left - 10;
					startY = e.clientY - rect.top - 10;
					startT = Date.now();
					deltaSpace = 0;
				}
			});
			
			canvas.addEventListener('mousemove', function (e) {
				if(downButton !== undefined) {
					deltaSpace++;
				}
			});
			
			canvas.addEventListener('mouseleave', function (e) {
				// Reset without allowing any action.
				downButton = undefined;
			});

			canvas.addEventListener('mouseup', function (e) {
				if(downButton !== e.button) {
					return;
				}
				
				downButton = undefined;
				
				let endT = Date.now();
				let deltaTime = endT - startT;
			
				const rect = canvas.getBoundingClientRect();
				let endX = e.clientX - rect.left - 10;
				let endY = e.clientY - rect.top - 10;

				if (deltaSpace < manClickDeltaSpace && deltaTime < manClickDeltaTime) {
					// Click
					reactButtonClick(e.button, startX, startY)
				}
				else {
					// Drag
					reactButtonDrag(e.button, startX, startY, endX, endY)
				}
			});
			
			
			
			
			
			document.onkeydown = (evt) => { 
				isKeyPressed[evt.keyCode] = true;
			}
			
			document.onkeyup = (evt) => {
				isKeyPressed[evt.keyCode] = false;
			}
			
			async function checkKeyPress() {
				let keys = [];
				for(let key in isKeyPressed) {
					if(isKeyPressed[key]) {
						keys.push(Number(key));
					}
				}
				
				if(keys.length !== 0) {
					reactKeyPress(keys);
				}
			}
			
			async function checkControllerPress() {
				const gamepads = navigator.getGamepads();
				if (!gamepads) {
					return;
				}

				for(let gp of gamepads) {
					if(!gp) {
						continue;
					}
					
					let buttons = [];
					
					for(let i = 0; i < gp.buttons.length; i++) {
						if(controllerButtonPressed(gp.buttons[i])) {
							buttons.push(i);
						}
					}
					
					if(buttons.length !== 0) {
						reactControllerPress(buttons);
					}
				}
			}
			
			function controllerButtonPressed(b) {
				if(typeof b === "object") {
					return b.pressed;
				}
				return b === 1.0;
			}
			
			let deadzone = 0.2;
			
			async function checkControllerSticks() {
				const gamepads = navigator.getGamepads();
				if (!gamepads) {
					return;
				}

				for(let gp of gamepads) {
					if(!gp) {
						continue;
					}
					
					let axes = gp.axes;
					for(let axis of axes) {
						// If any one axis is outside the deadzone, send the server all of the axes.
						if(Math.abs(axis) > deadzone) {
							reactControllerSticks(axes);
							return;
						}
					}
				}
			}
			
			async function reactControllerPress(buttons) {
				await socket.emitWithAck("on_controller_press", buttons);
			}
			
			async function reactControllerSticks(axes) {
				await socket.emitWithAck("on_controller_sticks", axes);
			}

			async function reactKeyPress(keys) {
				await socket.emitWithAck("on_key_press", keys);
			}
			
			async function reactButtonClick(button, x, y) {
				await socket.emitWithAck("on_mouse_click", button, x, y, IMAGE_SCALE_FACTOR);
			}
			
			async function reactButtonDrag(button, x1, y1, x2, y2) {
				await socket.emitWithAck("on_mouse_drag", button, x1, y1, x2, y2, IMAGE_SCALE_FACTOR);
			}
			
			async function updateCanvas() {
				if(isUpdating) {
					return;
				}
				
				isUpdating = true;
				
				//const start = Date.now();
				
				let R = await socket.emitWithAck("get_image_data", IMAGE_SCALE_FACTOR);
				
				//const end = Date.now();
				//const start2 = Date.now();
				
				let data = new Uint8ClampedArray(R.imageData.data);
				let imageData = new ImageData(data, canvas_width, canvas_height)
				ctx.putImageData(imageData, 0, 0);
				isUpdating = false;
				
				//const end2 = Date.now();
				///onsole.log(`Execution time: ${end - start} ms ${end2 - start2} ms`);
			}
			
			function startUpdateInterval() {
				timer = setInterval(() => {
					checkKeyPress();
					checkControllerPress();
					checkControllerSticks();
					updateCanvas();
				}, 1000 / FPS_RATE);
			}
		</script>
	</body>
</html>