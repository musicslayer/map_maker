<!DOCTYPE html>
<html lang="en-US">    
    <head>
        <title>Server Game</title>
    </head>

    <body>
        <p id="ID_GameResultText" style="white-space: pre;">Loading...</p>
        <canvas id="canvas" style="border:10px solid;display:none"></canvas>
        <button id="ID_ExitButton">Exit Game</button><br/>
        <text id="ID_DevText" style="white-space: pre;"></text>
        
        <script src="socket.io.min.js"></script>
        
        <script type="module">
            import { ImageCatalog } from "./ImageCatalog.js";
            import { CanvasPainter } from "./CanvasPainter.js";
            import { InputManager } from "./InputManager.js";
            
            const GameResultText = document.querySelector("#ID_GameResultText");
            const ExitButton = document.querySelector("#ID_ExitButton");
            const DevText = document.getElementById("ID_DevText");
            
            const BLACK = "#000000";
			const RED = "#B00000";
            
            const SOCKET_TIMEOUT = 10000;
            const INPUT_FPS_RATE = 60; // times per second inputs are queried
            const ANIMATION_TIME = 4; // seconds per animation cycle
            const ANIMATION_FRAMES = 8; // frames per animation cycle
            const NUM_TILES_X = 16;
            const NUM_TILES_Y = 12;
            const SIDE_PANEL_TILES = 10;
            const IMAGE_SCALE_FACTOR = 64;
            
            const MAX_CLICK_DELTA_SPACE = 10;
            const MAX_CLICK_DELTA_TIME = 100;
            
            // TODO "IMAGE_SCALE_FACTOR" and "128" and widths of text boxes needs to be fixed!
            
            const canvas_width = (NUM_TILES_X + SIDE_PANEL_TILES) * IMAGE_SCALE_FACTOR;
            const canvas_height = NUM_TILES_Y * IMAGE_SCALE_FACTOR;
            const canvas_showGrid = true;
            
            const canvas = document.getElementById("canvas");
            
            let imageCatalog;
            let canvasPainter;
            let inputManager;
            
            
            let socket = createSocket();
            let isSocketLoggedIn = false;
            
            let interval;
            let intervalDev;
            
            function createSocket() {
                let socket = io({
                    // Use these options to only allow websockets and avoid memory leaks.
                    upgrade: false,
                    transports: ["websocket"]
                });
                
                socket.on("connect", async (err) => {
                    GameResultText.style.color = BLACK;
                    GameResultText.innerHTML = "Please wait...";
                    
                    // Login based on the values in the sessionStorage.
                    if(window.sessionStorage.getItem("isActive")) {
                        let username = window.sessionStorage.getItem("username");
                        let hash = window.sessionStorage.getItem("hash");
                        let serverName = window.sessionStorage.getItem("serverName");
                        let worldName = window.sessionStorage.getItem("worldName");
                        let characterName = window.sessionStorage.getItem("characterName");
                        
                        let R = await queryServer("on_login_character", username, hash, characterName, serverName, worldName);
                        if(R.isSuccess) {
                            imageCatalog = new ImageCatalog();
                            await imageCatalog.createImageCatalog();
                            canvasPainter = new CanvasPainter(canvas, imageCatalog);
                            inputManager = new InputManager(canvas);

                            canvasPainter.setVisible(true);
                            GameResultText.style.color = BLACK;
                            GameResultText.innerHTML = "";
                            
                            startInterval();
                            startDevInterval();
                            requestAnimationFrame(drawClient);
                            
                            isSocketLoggedIn = true;
                        }
                        else {
                            GameResultText.style.color = RED;
                            GameResultText.innerHTML = R.errString;
                        }
                    }
                    else {
                        GameResultText.style.color = RED;
                        GameResultText.innerHTML = "You have not logged in as a character.";
                    }
                });
                
                socket.on("disconnect", (err) => {
                    window.sessionStorage.clear();
                    
                    isSocketLoggedIn = false;
                    
                    clearInterval(interval);
                    clearInterval(intervalDev);

                    canvasPainter?.setVisible(false);
                    GameResultText.style.color = RED;
                    GameResultText.innerHTML = "You have been disconnected from the server.";
                });
                
                return socket;
            }
            
            ExitButton.addEventListener("click", () => {
                // Disconnect and then navigate back to the login page.
                socket.disconnect(true);
                window.location.assign("/login");
            });
            
            canvas.addEventListener("contextmenu", (event) => {
                event.preventDefault();
            }, false);
            
            
            
            window.addEventListener("blur", (event) => {
                // TODO event.preventDefault();
                inputManager.onBlur(event);
            });
            
            window.addEventListener("focus", (event) => {
                // TODO event.preventDefault();
                inputManager.onFocus(event);
            });
            
            async function reactGamepadButtons(buttons) {
                await queryServerAfterLogIn("on_controller_press", buttons);
            }
            
            async function reactControllerSticks(axes) {
                await queryServerAfterLogIn("on_controller_sticks", axes);
            }

            async function reactKeys(keys) {
                await queryServerAfterLogIn("on_key_press", keys);
            }
            
            async function reactButtonClick(button, location, info) {
                await queryServerAfterLogIn("on_mouse_click", button, location, info);
            }
            
            async function reactButtonDrag(button, location1, info1, location2, info2) {
                await queryServerAfterLogIn("on_mouse_drag", button, location1, info1, location2, info2);
            }
            
            
            
            
            
            function startInterval() {
                // Continuously check for client inputs to send to the server.
                let interval = setInterval(async () => {
                    if(inputManager.inputsEnabled) {
                        await checkKeys();
                        await checkGamepadButtons();
                        await checkGamepadAxes();
                    }
                }, 1000 / INPUT_FPS_RATE);
            }
            
            function startDevInterval() {
                let intervalDev = setInterval(async () => {
                    await checkDevInfo();
                }, 1000 / INPUT_FPS_RATE);
            }
            
            async function checkDevInfo() {
                let R = await queryServerAfterLogIn("get_dev_data");
                if(R.isSuccess) {
                    let devData = R.devData;
                    
                    let currentTick = Math.floor(Number(devData.info.currentTick) / 60);
                    let serverInfo = devData.info.server;
                    let worldInfo = devData.info.world;
                    let mapInfo = devData.info.map;
                    let screenInfo = devData.info.screen;
                    let playerInfo = devData.info.player;
                    
                    DevText.innerHTML = "Current Tick: " + currentTick 
                    + "\nServer: " + serverInfo.id + " " + serverInfo.name
                    + "\nWorld: " + worldInfo.id + " " + worldInfo.name
                    + "\nMap: " + mapInfo.id + " " + mapInfo.name
                    + "\nScreen: " + "(" + screenInfo.x + "," + screenInfo.y + ") " + screenInfo.name
                    + "\nPlayer: " + "(" + playerInfo.x + "," + playerInfo.y + ")";
                }
            }
            
            async function queryServer(eventName, ...args) {
                let response = {
                    "isSuccess": false,
                    "errString": "Unable to connect to the server."
                };
                
                if(socket.connected) {
                    try {
                        response = await socket.timeout(SOCKET_TIMEOUT).emitWithAck(eventName, ...args);
                    }
                    catch(err) {
                    }
                }
                
                return response;
            }
            
            async function queryServerAfterLogIn(eventName, ...args) {
                let response = {
                    "isSuccess": false,
                    "errString": "Unable to connect to the server."
                };
                
                if(socket.connected && isSocketLoggedIn) {
                    try {
                        response = await socket.timeout(SOCKET_TIMEOUT).emitWithAck(eventName, ...args);
                    }
                    catch(err) {
                    }
                }
                
                return response;
            }
            
            
            
            
            
            async function drawClient(time) {
                let R = await queryServerAfterLogIn("get_client_data");
                if(R.isSuccess) {
                    let clientData = R.clientData;
                    canvasPainter.drawClient(time, clientData);
                    requestAnimationFrame(drawClient);
                }
            }
            
            canvas.addEventListener("mousedown", (event) => {
                event.preventDefault()
                inputManager.onMouseDown(event);
            });
            
            canvas.addEventListener("mousemove", (event) => {
                event.preventDefault()
                inputManager.onMouseMove(event);
            });
            
            canvas.addEventListener("mouseup", async (event) => {
                event.preventDefault()
                let [button, deltaSpace, deltaTime, location1, info1, location2, info2] = inputManager.onMouseUp(event);
                
                // Perform an action right after the mouseup event instead of waiting for the interval.
                if(deltaSpace < MAX_CLICK_DELTA_SPACE && deltaTime < MAX_CLICK_DELTA_TIME) {
                    // Click
                    if(location1) {
                        await reactButtonClick(button, location1, info1)
                    }
                }
                else {
                    // Drag
                    if(location1 && location2) {
                        await reactButtonDrag(button, location1, info1, location2, info2)
                    }
                }
            });
            
            document.onkeydown = (event) => {
                event.preventDefault();
                inputManager.onKeyDown(event);
            }
            
            document.onkeyup = (event) => {
                event.preventDefault();
                inputManager.onKeyUp(event);
            }
            
            async function checkKeys() {
                let keys = inputManager.getKeys();
                if(keys.length !== 0) {
                    await reactKeys(keys);
                }
            }
            
            async function checkGamepadButtons() {
                // Check all gamepads that are connected.
                for(let gamepad of navigator.getGamepads()) {
                    if(gamepad) {
                        let buttons = inputManager.getGamepadButtons(gamepad);
                        if(buttons.length !== 0) {
                            await reactGamepadButtons(buttons);
                        }
                    }
                }
            }
            
            async function checkGamepadAxes() {
                let gamepads = navigator.getGamepads();
                if (!gamepads) {
                    return;
                }

                for(let gp of gamepads) {
                    if(!gp) {
                        continue;
                    }
                    
                    let axes = gp.axes;
                    for(let axis of axes) {
                        // If any one axis is outside the deadzone, send the server all of the axes.
                        if(Math.abs(axis) > DEADZONE) {
                            await reactControllerSticks(axes);
                            return;
                        }
                    }
                }
            }
        </script>
    </body>
</html>