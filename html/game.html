<!DOCTYPE html>
<html lang="en-US">    
    <head>
        <title>Server Game</title>
    </head>

    <body>
        <p id="ID_GameResultText" style="white-space: pre;">Loading...</p>
        <canvas id="canvas" style="border:10px solid;display:none"></canvas>
        <button id="ID_ExitButton">Exit Game</button><br/>
        <text id="ID_DevText" style="white-space: pre;"></text>
        
        <script src="socket.io.min.js"></script>
        
        <script type="module">
            import { CanvasPainter } from "./CanvasPainter.js";
            import { ImageCatalog } from "./ImageCatalog.js";
            
            const GameResultText = document.querySelector("#ID_GameResultText");
            const ExitButton = document.querySelector("#ID_ExitButton");
            const DevText = document.getElementById("ID_DevText");
            
            const BLACK = "#000000";
			const RED = "#B00000";
            
            const SOCKET_TIMEOUT = 10000;
            const INPUT_FPS_RATE = 60; // times per second inputs are queried
            const ANIMATION_TIME = 4; // seconds per animation cycle
            const ANIMATION_FRAMES = 8; // frames per animation cycle
            const NUM_TILES_X = 16;
            const NUM_TILES_Y = 12;
            const SIDE_PANEL_TILES = 10;
            const IMAGE_SCALE_FACTOR = 64;
            
            // TODO "IMAGE_SCALE_FACTOR" and "128" and widths of text boxes needs to be fixed!
            
            const canvas_width = (NUM_TILES_X + SIDE_PANEL_TILES) * IMAGE_SCALE_FACTOR;
            const canvas_height = NUM_TILES_Y * IMAGE_SCALE_FACTOR;
            const canvas_showGrid = true;
            
            const canvas = document.getElementById("canvas");
            let inputsEnabled = true;
            
            let canvasPainter;
            let imageCatalog;
            
            let socket = createSocket();
            let isSocketLoggedIn = false;
            
            let interval;
            let intervalDev;
            
            function createSocket() {
                let socket = io({
                    // Use these options to only allow websockets and avoid memory leaks.
                    upgrade: false,
                    transports: ["websocket"]
                });
                
                socket.on("connect", async (err) => {
                    GameResultText.style.color = BLACK;
                    GameResultText.innerHTML = "Please wait...";
                    
                    // Login based on the values in the sessionStorage.
                    if(window.sessionStorage.getItem("isActive")) {
                        let username = window.sessionStorage.getItem("username");
                        let hash = window.sessionStorage.getItem("hash");
                        let serverName = window.sessionStorage.getItem("serverName");
                        let worldName = window.sessionStorage.getItem("worldName");
                        let characterName = window.sessionStorage.getItem("characterName");
                        
                        let R = await queryServer("on_login_character", username, hash, characterName, serverName, worldName);
                        if(R.isSuccess) {
                            imageCatalog = new ImageCatalog();
                            await imageCatalog.createImageCatalog();
                            
                            canvasPainter = new CanvasPainter(canvas, imageCatalog);

                            canvasPainter.setVisible(true);
                            GameResultText.style.color = BLACK;
                            GameResultText.innerHTML = "";
                            
                            startInterval();
                            startDevInterval();
                            requestAnimationFrame(drawClient);
                            
                            isSocketLoggedIn = true;
                        }
                        else {
                            GameResultText.style.color = RED;
                            GameResultText.innerHTML = R.errString;
                        }
                    }
                    else {
                        GameResultText.style.color = RED;
                        GameResultText.innerHTML = "You have not logged in as a character.";
                    }
                });
                
                socket.on("disconnect", (err) => {
                    window.sessionStorage.clear();
                    
                    isSocketLoggedIn = false;
                    
                    clearInterval(interval);
                    clearInterval(intervalDev);

                    canvasPainter?.setVisible(false);
                    GameResultText.style.color = RED;
                    GameResultText.innerHTML = "You have been disconnected from the server.";
                });
                
                return socket;
            }
            
            ExitButton.addEventListener("click", () => {
                // Disconnect and then navigate back to the login page.
                socket.disconnect(true);
                window.location.assign("/login");
            });
            
            canvas.addEventListener("contextmenu", (e) => {
                e.preventDefault();
            }, false);
            
            const maxClickDeltaSpace = 10;
            const maxClickDeltaTime = 100;
            let deltaSpace;
            let startX;
            let startY;
            let startT;
            
            let downButton;

            canvas.addEventListener("mousedown", (e) => {
                e.preventDefault()
                
                if(downButton === undefined) {
                    downButton = e.button;
                    let rect = canvas.getBoundingClientRect();
                    startX = e.clientX - rect.left - 10;
                    startY = e.clientY - rect.top - 10;
                    startT = Date.now();
                    deltaSpace = 0;
                }
            });
            
            canvas.addEventListener("mousemove", (e) => {
                if(downButton !== undefined) {
                    deltaSpace++;
                }
            });

            canvas.addEventListener("mouseup", async (e) => {
                if(downButton !== e.button) {
                    return;
                }
                
                downButton = undefined;
                
                let endT = Date.now();
                let deltaTime = endT - startT;
            
                let rect = canvas.getBoundingClientRect();
                let endX = e.clientX - rect.left - 10;
                let endY = e.clientY - rect.top - 10;
                
                
                
                let var_isScreen1 = isScreen(startX, startY);
                let var_isInventory1 = isInventory(startX, startY);
                let var_isPurse1 = isPurse(startX, startY);
                
                let location1;
                let info1 = [];
                
                if(var_isScreen1 !== undefined) {
                    location1 = "screen";
                    info1.push(var_isScreen1[0]);
                    info1.push(var_isScreen1[1]);
                }
                else if(var_isInventory1 !== undefined) {
                    location1 = "inventory";
                    info1.push(var_isInventory1);
                }
                else if(var_isPurse1 !== undefined) {
                    location1 = "purse";
                }
                
                
                
                let var_isScreen2 = isScreen(endX, endY);
                let var_isInventory2 = isInventory(endX, endY);
                let var_isPurse2 = isPurse(endX, endY);
                
                let location2;
                let info2 = [];
                
                if(var_isScreen2 !== undefined) {
                    location2 = "screen";
                    info2.push(var_isScreen2[0]);
                    info2.push(var_isScreen2[1]);
                }
                else if(var_isInventory2 !== undefined) {
                    location2 = "inventory";
                    info2.push(var_isInventory2);
                }
                else if(var_isPurse2 !== undefined) {
                    location2 = "purse";
                }

                if (deltaSpace < maxClickDeltaSpace && deltaTime < maxClickDeltaTime) {
                    // Click
                    if(location1) {
                        await reactButtonClick(e.button, location1, info1)
                    }
                }
                else {
                    // Drag
                    if(location1 && location2) {
                        await reactButtonDrag(e.button, location1, info1, location2, info2)
                    }
                }
            });
            
            
            
            
            let isKeyPressed = {};
            
            document.onkeydown = (evt) => {
                evt.preventDefault();
                isKeyPressed[evt.keyCode] = true;
            }
            
            document.onkeyup = (evt) => {
                evt.preventDefault();
                isKeyPressed[evt.keyCode] = false;
            }
            
            async function checkKeyPress() {
                let keys = [];
                for(let key in isKeyPressed) {
                    if(isKeyPressed[key]) {
                        keys.push(Number(key));
                    }
                }
                
                if(keys.length !== 0) {
                    await reactKeyPress(keys);
                }
            }
            
            async function checkControllerPress() {
                let gamepads = navigator.getGamepads();
                if (!gamepads) {
                    return;
                }

                for(let gp of gamepads) {
                    if(!gp) {
                        continue;
                    }
                    
                    let buttons = [];
                    
                    for(let i = 0; i < gp.buttons.length; i++) {
                        if(controllerButtonPressed(gp.buttons[i])) {
                            buttons.push(i);
                        }
                    }
                    
                    if(buttons.length !== 0) {
                        await reactControllerPress(buttons);
                    }
                }
            }
            
            function controllerButtonPressed(b) {
                if(typeof b === "object") {
                    return b.pressed;
                }
                return b === 1.0;
            }
            
            let deadzone = 0.2;
            
            async function checkControllerSticks() {
                let gamepads = navigator.getGamepads();
                if (!gamepads) {
                    return;
                }

                for(let gp of gamepads) {
                    if(!gp) {
                        continue;
                    }
                    
                    let axes = gp.axes;
                    for(let axis of axes) {
                        // If any one axis is outside the deadzone, send the server all of the axes.
                        if(Math.abs(axis) > deadzone) {
                            await reactControllerSticks(axes);
                            return;
                        }
                    }
                }
            }
            
            window.addEventListener("blur", (e) => {
                inputsEnabled = false;
                isKeyPressed = {};
            });
            
            window.addEventListener("focus", (e) => {
                inputsEnabled = true;
            });
            
            async function reactControllerPress(buttons) {
                await queryServerAfterLogIn("on_controller_press", buttons);
            }
            
            async function reactControllerSticks(axes) {
                await queryServerAfterLogIn("on_controller_sticks", axes);
            }

            async function reactKeyPress(keys) {
                await queryServerAfterLogIn("on_key_press", keys);
            }
            
            async function reactButtonClick(button, location, info) {
                await queryServerAfterLogIn("on_mouse_click", button, location, info);
            }
            
            async function reactButtonDrag(button, location1, info1, location2, info2) {
                await queryServerAfterLogIn("on_mouse_drag", button, location1, info1, location2, info2);
            }
            
            function isScreen(x, y) {
                let nScreen;

                if(x >= 0 && x < NUM_TILES_X * IMAGE_SCALE_FACTOR && y >= 0 && y < NUM_TILES_Y * IMAGE_SCALE_FACTOR) {
                    // Return normalized (tile) x,y
                    nScreen = [Math.floor(x / IMAGE_SCALE_FACTOR), Math.floor(y / IMAGE_SCALE_FACTOR)];
                }

                return nScreen;
            }

            function isInventory(x, y) {
                let originInventoryX = 17;
                let originInventoryY = 7;
                let inventoryWidth = 9;
                let inventoryHeight = 5;

                let slot;

                if(x >= originInventoryX * IMAGE_SCALE_FACTOR && x < (originInventoryX + inventoryWidth) * IMAGE_SCALE_FACTOR && y >= originInventoryY  * IMAGE_SCALE_FACTOR && y < (originInventoryY + inventoryHeight) * IMAGE_SCALE_FACTOR) {
                    // Return inventory slot
                    let nx = Math.floor((x / IMAGE_SCALE_FACTOR) - originInventoryX);
                    let ny = Math.floor((y / IMAGE_SCALE_FACTOR) - originInventoryY);
                    slot = ny * 9 + nx;
                }

                return slot;
            }

            function isPurse(x, y) {
                let originPurseX = 17;
                let originPurseY = 0;
                let purseWidth = 1;
                let purseHeight = 1;

                let b = x >= originPurseX * IMAGE_SCALE_FACTOR && x < (originPurseX + purseWidth) * IMAGE_SCALE_FACTOR && y >= originPurseY  * IMAGE_SCALE_FACTOR && y < (originPurseY + purseHeight) * IMAGE_SCALE_FACTOR;
                return b ? b : undefined;
            }
            
            
            
            
            
            function startInterval() {
                // Continuously check for client inputs to send to the server.
                let interval = setInterval(async () => {
                    if(inputsEnabled) {
                        await checkKeyPress();
                        await checkControllerPress();
                        await checkControllerSticks();
                    }
                }, 1000 / INPUT_FPS_RATE);
            }
            
            function startDevInterval() {
                let intervalDev = setInterval(async () => {
                    await checkDevInfo();
                }, 1000 / INPUT_FPS_RATE);
            }
            
            async function checkDevInfo() {
                let R = await queryServerAfterLogIn("get_dev_data");
                if(R.isSuccess) {
                    let devData = R.devData;
                    
                    let currentTick = Math.floor(Number(devData.info.currentTick) / 60);
                    let serverInfo = devData.info.server;
                    let worldInfo = devData.info.world;
                    let mapInfo = devData.info.map;
                    let screenInfo = devData.info.screen;
                    let playerInfo = devData.info.player;
                    
                    DevText.innerHTML = "Current Tick: " + currentTick 
                    + "\nServer: " + serverInfo.id + " " + serverInfo.name
                    + "\nWorld: " + worldInfo.id + " " + worldInfo.name
                    + "\nMap: " + mapInfo.id + " " + mapInfo.name
                    + "\nScreen: " + "(" + screenInfo.x + "," + screenInfo.y + ") " + screenInfo.name
                    + "\nPlayer: " + "(" + playerInfo.x + "," + playerInfo.y + ")";
                }
            }
            
            async function queryServer(eventName, ...args) {
                let response = {
                    "isSuccess": false,
                    "errString": "Unable to connect to the server."
                };
                
                if(socket.connected) {
                    try {
                        response = await socket.timeout(SOCKET_TIMEOUT).emitWithAck(eventName, ...args);
                    }
                    catch(err) {
                    }
                }
                
                return response;
            }
            
            async function queryServerAfterLogIn(eventName, ...args) {
                let response = {
                    "isSuccess": false,
                    "errString": "Unable to connect to the server."
                };
                
                if(socket.connected && isSocketLoggedIn) {
                    try {
                        response = await socket.timeout(SOCKET_TIMEOUT).emitWithAck(eventName, ...args);
                    }
                    catch(err) {
                    }
                }
                
                return response;
            }
            
            
            
            
            
            async function drawClient(time) {
                let R = await queryServerAfterLogIn("get_client_data");
                if(R.isSuccess) {
                    let clientData = R.clientData;
                    canvasPainter.drawClient(time, clientData);
                    requestAnimationFrame(drawClient);
                }
            }
            
            
        </script>
    </body>
</html>